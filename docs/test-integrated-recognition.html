<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Two-Zone Recognition Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #1a1a1a;
            color: #ddd;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: #4A90E2;
        }
        
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        button {
            background: #4A90E2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #357ABD;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .pipeline-visualization {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pipeline-stage {
            flex: 1;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stage-active {
            background: #2E5C3E;
            border: 2px solid #2ECC71;
        }
        
        .stage-complete {
            background: #5C2E2E;
            border: 2px solid #E74C3C;
        }
        
        .stage-error {
            background: #5C3E2E;
            border: 2px solid #F39C12;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .result-panel {
            background: #333;
            padding: 15px;
            border-radius: 8px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: #2a2a2a;
            border-radius: 4px;
        }
        
        .zone-results {
            margin-top: 15px;
        }
        
        .core-result {
            background: rgba(231, 76, 60, 0.1);
            border-left: 3px solid #E74C3C;
            padding: 8px;
            margin: 5px 0;
        }
        
        .regular-result {
            background: rgba(46, 204, 113, 0.1);
            border-left: 3px solid #2ECC71;
            padding: 8px;
            margin: 5px 0;
        }
        
        canvas {
            background: #000;
            border: 1px solid #444;
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        
        .error {
            background: #5C2E2E;
            color: #E74C3C;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .success {
            background: #2E5C3E;
            color: #2ECC71;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .info {
            background: #2E3E5C;
            color: #3498DB;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .log-output {
            background: #0a0a0a;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 10px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
            margin: 10px 0;
        }
        
        #fileInput {
            margin-bottom: 10px;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }
        
        .comparison-table th {
            background: #333;
        }
        
        .confidence-bar {
            width: 100%;
            height: 10px;
            background: #444;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #E74C3C, #F39C12, #2ECC71);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Integrated Two-Zone Recognition System Test</h1>
        
        <div class="test-section">
            <h2>Test Configuration</h2>
            <input type="file" id="fileInput" accept="image/*">
            <br>
            <button onclick="generateTestImage()">Generate Synthetic Test Image</button>
            <button onclick="runFullPipeline()">Run Full Pipeline Test</button>
            <button onclick="runGridMappingOnly()">Test Grid Mapping Only</button>
            <button onclick="runRecognitionOnly()">Test Recognition Only</button>
            <button onclick="compareEngines()">Compare V1 vs V2 Engines</button>
            <button onclick="runPerformanceTest()">Performance Benchmark</button>
            <button onclick="clearResults()">Clear Results</button>
        </div>
        
        <div class="test-section">
            <h2>Pipeline Status</h2>
            <div class="pipeline-visualization">
                <div class="pipeline-stage" id="stage-upload">
                    <h4>1. Upload</h4>
                    <p>Image Loading</p>
                </div>
                <div class="pipeline-stage" id="stage-grid">
                    <h4>2. Grid Mapping</h4>
                    <p>Two-Zone Detection</p>
                </div>
                <div class="pipeline-stage" id="stage-recognition">
                    <h4>3. Recognition</h4>
                    <p>Zone-Aware Analysis</p>
                </div>
                <div class="pipeline-stage" id="stage-results">
                    <h4>4. Results</h4>
                    <p>Final Output</p>
                </div>
            </div>
        </div>
        
        <div class="results-grid">
            <div class="result-panel">
                <h3>Image Preview</h3>
                <canvas id="imageCanvas" width="400" height="300"></canvas>
            </div>
            
            <div class="result-panel">
                <h3>Grid Mapping Results</h3>
                <div id="gridResults">
                    <p>No grid mapping performed yet.</p>
                </div>
            </div>
            
            <div class="result-panel">
                <h3>Recognition Results</h3>
                <div id="recognitionResults">
                    <p>No recognition performed yet.</p>
                </div>
            </div>
            
            <div class="result-panel">
                <h3>Performance Metrics</h3>
                <div id="performanceResults">
                    <p>No performance data available.</p>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <h2>Detailed Analysis</h2>
            <div id="detailedResults">
                <p>Run a test to see detailed analysis results.</p>
            </div>
        </div>
        
        <div class="test-section">
            <h2>System Log</h2>
            <div class="log-output" id="logOutput">
                System initialized. Ready for testing.
            </div>
        </div>
    </div>

    <!-- Load required scripts -->
    <script src="two-zone-grid-mapper.js"></script>
    <script src="grid-mapper-v2.js"></script>
    <script src="recognition-engine/two-zone-recognition-engine.js"></script>
    <script src="recognition-engine/recognition-engine-v2.js"></script>
    
    <script>
        // Global test state
        let currentImage = null;
        let currentGridMapping = null;
        let currentRecognitionResults = null;
        
        // Pipeline stage management
        function setStageStatus(stageId, status) {
            const stage = document.getElementById(stageId);
            stage.className = 'pipeline-stage';
            if (status) {
                stage.classList.add(`stage-${status}`);
            }
        }
        
        // Logging
        function log(message, type = 'info') {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'color: #E74C3C' : 
                             type === 'success' ? 'color: #2ECC71' : 
                             type === 'warning' ? 'color: #F39C12' : 'color: #0f0';
            
            logOutput.innerHTML += `<div style="${className}">[${timestamp}] ${message}</div>`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }
        
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        currentImage = img;
                        displayImage(img);
                        setStageStatus('stage-upload', 'complete');
                        log('Image loaded successfully', 'success');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        function displayImage(img) {
            const canvas = document.getElementById('imageCanvas');
            const ctx = canvas.getContext('2d');
            
            // Scale image to fit canvas
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
            const width = img.width * scale;
            const height = img.height * scale;
            const x = (canvas.width - width) / 2;
            const y = (canvas.height - height) / 2;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, x, y, width, height);
        }
        
        function generateTestImage() {
            log('Generating synthetic test image...', 'info');
            setStageStatus('stage-upload', 'active');
            
            const canvas = document.createElement('canvas');
            canvas.width = 1920;
            canvas.height = 1080;
            const ctx = canvas.getContext('2d');
            
            // Dark space background
            const gradient = ctx.createRadialGradient(960, 540, 0, 960, 540, 800);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f0f23');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add stars
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2;
                ctx.fillRect(x, y, size, size);
            }
            
            const gridCenter = { x: 960, y: 540 };
            
            // Core zone - 3 upgrades in triangular arrangement
            drawModHex(ctx, gridCenter.x - 60, gridCenter.y - 40, 28, '#E74C3C', 'Body', true);
            drawModHex(ctx, gridCenter.x + 60, gridCenter.y - 40, 28, '#3498DB', 'Shield', false);
            drawModHex(ctx, gridCenter.x, gridCenter.y + 20, 28, '#F39C12', 'Weapon', true);
            
            // Zone separation gap
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, gridCenter.y + 60, canvas.width, 40);
            
            // Regular zone - 4-wide grid
            const startY = gridCenter.y + 120;
            const hexRadius = 24;
            const columnSpacing = 42;
            const rowSpacing = 48;
            
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 4; col++) {
                    const x = gridCenter.x - (1.5 * columnSpacing) + (col * columnSpacing);
                    const y = startY + (row * rowSpacing);
                    const offsetX = (row % 2 === 1) ? (columnSpacing / 2) : 0;
                    
                    const selected = Math.random() > 0.7; // 30% chance of selection
                    const modName = `M${row}${col}`;
                    const color = selected ? '#2ECC71' : '#7F8C8D';
                    
                    drawModHex(ctx, x + offsetX, y, hexRadius, color, modName, selected);
                }
            }
            
            // Convert to image
            const img = new Image();
            img.onload = function() {
                currentImage = img;
                displayImage(img);
                setStageStatus('stage-upload', 'complete');
                log('Synthetic test image generated with two-zone layout', 'success');
            };
            img.src = canvas.toDataURL();
        }
        
        function drawModHex(ctx, x, y, radius, color, label, selected) {
            ctx.save();
            ctx.translate(x, y);
            
            // Draw hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const hx = radius * Math.cos(angle);
                const hy = radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(hx, hy);
                } else {
                    ctx.lineTo(hx, hy);
                }
            }
            ctx.closePath();
            
            // Fill based on selection state
            if (selected) {
                ctx.fillStyle = color + '80';
                ctx.fill();
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.stroke();
            } else {
                ctx.fillStyle = color + '30';
                ctx.fill();
                ctx.strokeStyle = color + '80';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Label
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 0, 0);
            
            ctx.restore();
        }
        
        async function runFullPipeline() {
            if (!currentImage) {
                log('Please load or generate an image first!', 'error');
                return;
            }
            
            log('Starting full pipeline test...', 'info');
            
            try {
                // Stage 1: Grid Mapping
                log('Stage 1: Running two-zone grid mapping...', 'info');
                setStageStatus('stage-grid', 'active');
                
                const gridMapper = new NovaGridMapper.GridMapper();
                const gridResult = await gridMapper.mapScreenshot(currentImage);
                currentGridMapping = gridResult;
                
                setStageStatus('stage-grid', 'complete');
                log(`Grid mapping complete: ${gridResult.coordinateMap.size} positions detected`, 'success');
                displayGridResults(gridResult);
                
                // Stage 2: Recognition
                log('Stage 2: Running two-zone recognition...', 'info');
                setStageStatus('stage-recognition', 'active');
                
                // Create mock region data for recognition
                const regionData = createMockRegionData(gridResult);
                
                const recognitionEngine = new NovaRecognitionEngine.RecognitionEngine();
                const recognitionResult = await recognitionEngine.analyzeRegions(regionData, {
                    gridMappingResult: gridResult
                });
                
                currentRecognitionResults = recognitionResult;
                
                setStageStatus('stage-recognition', 'complete');
                setStageStatus('stage-results', 'complete');
                log(`Recognition complete: ${recognitionResult.detail.detectionResults.size} mods analyzed`, 'success');
                
                displayRecognitionResults(recognitionResult);
                displayPerformanceResults(recognitionResult);
                displayDetailedAnalysis(gridResult, recognitionResult);
                
            } catch (error) {
                log(`Pipeline failed: ${error.message}`, 'error');
                setStageStatus('stage-grid', 'error');
                setStageStatus('stage-recognition', 'error');
                setStageStatus('stage-results', 'error');
            }
        }
        
        function createMockRegionData(gridResult) {
            const regionData = new Map();
            
            // Create mock image data for each detected position
            for (const [positionId, coordData] of gridResult.coordinateMap) {
                // Create a small canvas for this region
                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                
                // Draw mock mod region
                ctx.fillStyle = coordData.zone === 'core' ? '#E74C3C40' : '#2ECC7140';
                ctx.fillRect(0, 0, 48, 48);
                
                const imageData = ctx.getImageData(0, 0, 48, 48);
                
                regionData.set(positionId, {
                    imageData,
                    bounds: coordData.hexBounds || coordData.bounds,
                    modName: coordData.modName,
                    extractionMetadata: { quality: 0.8 }
                });
            }
            
            return regionData;
        }
        
        function displayGridResults(gridResult) {
            const container = document.getElementById('gridResults');
            
            let html = '<h4>Grid Mapping Summary</h4>';
            
            // Basic metrics
            html += '<div class="metric">';
            html += '<span>Total Positions:</span>';
            html += `<span>${gridResult.coordinateMap.size}</span>`;
            html += '</div>';
            
            html += '<div class="metric">';
            html += '<span>Scaling Factor:</span>';
            html += `<span>${gridResult.scalingFactor.toFixed(3)}</span>`;
            html += '</div>';
            
            html += '<div class="metric">';
            html += '<span>Confidence:</span>';
            html += `<span>${(gridResult.confidence * 100).toFixed(1)}%</span>`;
            html += '</div>';
            
            // Two-zone breakdown
            if (gridResult.gridMetadata.twoZoneData) {
                const tzData = gridResult.gridMetadata.twoZoneData;
                
                html += '<h4>Two-Zone Breakdown</h4>';
                html += '<div class="core-result">';
                html += `<strong>Core Zone:</strong> ${tzData.coreZone.count} upgrades `;
                html += `(${(tzData.coreZone.confidence * 100).toFixed(1)}% confidence)`;
                html += '</div>';
                
                html += '<div class="regular-result">';
                html += `<strong>Regular Zone:</strong> ${tzData.regularZone.count} mods `;
                html += `(${(tzData.regularZone.confidence * 100).toFixed(1)}% confidence)`;
                html += '</div>';
                
                html += '<div class="metric">';
                html += '<span>Zone Boundary Y:</span>';
                html += `<span>${Math.round(tzData.zoneBoundary.boundaryY)}</span>`;
                html += '</div>';
            }
            
            container.innerHTML = html;
        }
        
        function displayRecognitionResults(recognitionResult) {
            const container = document.getElementById('recognitionResults');
            
            let html = '<h4>Recognition Summary</h4>';
            
            const results = recognitionResult.detail.detectionResults;
            const stats = recognitionResult.detail.overallStats;
            
            html += '<div class="metric">';
            html += '<span>Analyzed Regions:</span>';
            html += `<span>${results.size}</span>`;
            html += '</div>';
            
            html += '<div class="metric">';
            html += '<span>Average Confidence:</span>';
            html += `<span>${(stats.averageConfidence * 100).toFixed(1)}%</span>`;
            html += '</div>';
            
            // Zone breakdown if available
            if (stats.zoneBreakdown) {
                html += '<h4>Zone Analysis</h4>';
                
                if (stats.zoneBreakdown.coreUpgrades) {
                    html += '<div class="core-result">';
                    html += `<strong>Core Upgrades:</strong> ${stats.zoneBreakdown.coreUpgrades.count} analyzed `;
                    html += `(${(stats.zoneBreakdown.coreUpgrades.averageConfidence * 100).toFixed(1)}% avg confidence)`;
                    html += '</div>';
                }
                
                if (stats.zoneBreakdown.regularMods) {
                    html += '<div class="regular-result">';
                    html += `<strong>Regular Mods:</strong> ${stats.zoneBreakdown.regularMods.count} analyzed `;
                    html += `(${(stats.zoneBreakdown.regularMods.averageConfidence * 100).toFixed(1)}% avg confidence)`;
                    html += '</div>';
                }
            }
            
            // Selection summary
            let selectedCount = 0;
            for (const result of results.values()) {
                if (result.selected) selectedCount++;
            }
            
            html += '<div class="metric">';
            html += '<span>Selected Mods:</span>';
            html += `<span>${selectedCount} / ${results.size}</span>`;
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        function displayPerformanceResults(recognitionResult) {
            const container = document.getElementById('performanceResults');
            const metadata = recognitionResult.detail.processingMetadata;
            
            let html = '<h4>Performance Metrics</h4>';
            
            html += '<div class="metric">';
            html += '<span>Processing Time:</span>';
            html += `<span>${metadata.processingTime?.toFixed(1) || 'N/A'}ms</span>`;
            html += '</div>';
            
            html += '<div class="metric">';
            html += '<span>Engine Version:</span>';
            html += `<span>${metadata.engineVersion || 'Unknown'}</span>`;
            html += '</div>';
            
            html += '<div class="metric">';
            html += '<span>Used Two-Zone:</span>';
            html += `<span>${metadata.usedTwoZone ? 'Yes' : 'No'}</span>`;
            html += '</div>';
            
            if (metadata.performanceStats) {
                const stats = metadata.performanceStats;
                
                html += '<div class="metric">';
                html += '<span>Two-Zone Usage:</span>';
                html += `<span>${stats.twoZoneUsage || 0}</span>`;
                html += '</div>';
                
                html += '<div class="metric">';
                html += '<span>Legacy Fallbacks:</span>';
                html += `<span>${stats.legacyFallbacks || 0}</span>`;
                html += '</div>';
            }
            
            container.innerHTML = html;
        }
        
        function displayDetailedAnalysis(gridResult, recognitionResult) {
            const container = document.getElementById('detailedResults');
            
            let html = '<h3>Detailed Analysis Results</h3>';
            
            // Create comparison table
            html += '<table class="comparison-table">';
            html += '<thead><tr><th>Position</th><th>Zone</th><th>Mod Name</th><th>Selected</th><th>Confidence</th><th>Algorithm</th></tr></thead>';
            html += '<tbody>';
            
            for (const [positionId, result] of recognitionResult.detail.detectionResults) {
                const gridData = gridResult.coordinateMap.get(positionId);
                
                html += '<tr>';
                html += `<td>${positionId}</td>`;
                html += `<td><span class="zone-${result.analysisData?.zone || 'unknown'}">${result.analysisData?.zone || 'Unknown'}</span></td>`;
                html += `<td>${result.modName || 'N/A'}</td>`;
                html += `<td>${result.selected ? '✓' : '✗'}</td>`;
                html += '<td>';
                html += '<div class="confidence-bar">';
                html += `<div class="confidence-fill" style="width: ${(result.confidence * 100).toFixed(0)}%"></div>`;
                html += '</div>';
                html += `${(result.confidence * 100).toFixed(1)}%`;
                html += '</td>';
                html += `<td>${result.metadata?.algorithm || 'Unknown'}</td>`;
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }
        
        async function runGridMappingOnly() {
            if (!currentImage) {
                log('Please load or generate an image first!', 'error');
                return;
            }
            
            log('Running grid mapping test only...', 'info');
            setStageStatus('stage-grid', 'active');
            
            try {
                const gridMapper = new NovaGridMapper.GridMapper();
                const gridResult = await gridMapper.mapScreenshot(currentImage);
                currentGridMapping = gridResult;
                
                setStageStatus('stage-grid', 'complete');
                log(`Grid mapping complete: ${gridResult.coordinateMap.size} positions detected`, 'success');
                displayGridResults(gridResult);
                
            } catch (error) {
                log(`Grid mapping failed: ${error.message}`, 'error');
                setStageStatus('stage-grid', 'error');
            }
        }
        
        async function runRecognitionOnly() {
            if (!currentGridMapping) {
                log('Please run grid mapping first!', 'error');
                return;
            }
            
            log('Running recognition test only...', 'info');
            setStageStatus('stage-recognition', 'active');
            
            try {
                const regionData = createMockRegionData(currentGridMapping);
                const recognitionEngine = new NovaRecognitionEngine.RecognitionEngine();
                const recognitionResult = await recognitionEngine.analyzeRegions(regionData, {
                    gridMappingResult: currentGridMapping
                });
                
                currentRecognitionResults = recognitionResult;
                
                setStageStatus('stage-recognition', 'complete');
                log(`Recognition complete: ${recognitionResult.detail.detectionResults.size} mods analyzed`, 'success');
                
                displayRecognitionResults(recognitionResult);
                displayPerformanceResults(recognitionResult);
                
            } catch (error) {
                log(`Recognition failed: ${error.message}`, 'error');
                setStageStatus('stage-recognition', 'error');
            }
        }
        
        function compareEngines() {
            log('Engine comparison not yet implemented', 'warning');
        }
        
        function runPerformanceTest() {
            log('Performance benchmark not yet implemented', 'warning');
        }
        
        function clearResults() {
            // Clear all results
            document.getElementById('gridResults').innerHTML = '<p>No grid mapping performed yet.</p>';
            document.getElementById('recognitionResults').innerHTML = '<p>No recognition performed yet.</p>';
            document.getElementById('performanceResults').innerHTML = '<p>No performance data available.</p>';
            document.getElementById('detailedResults').innerHTML = '<p>Run a test to see detailed analysis results.</p>';
            document.getElementById('logOutput').innerHTML = 'System cleared. Ready for testing.';
            
            // Reset pipeline stages
            setStageStatus('stage-upload', null);
            setStageStatus('stage-grid', null);
            setStageStatus('stage-recognition', null);
            setStageStatus('stage-results', null);
            
            // Clear data
            currentImage = null;
            currentGridMapping = null;
            currentRecognitionResults = null;
            
            // Clear canvas
            const canvas = document.getElementById('imageCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            log('System cleared and ready for new tests', 'success');
        }
        
        // Initialize test interface
        window.onload = function() {
            log('Integrated Two-Zone Recognition Test System initialized', 'success');
            generateTestImage(); // Generate initial test image
        };
    </script>
</body>
</html>